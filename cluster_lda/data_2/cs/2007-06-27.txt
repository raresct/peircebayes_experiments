0706.3984	cs.SE cs.PF	A Comparison of Push and Pull Techniques for Ajax	Ajax applications are designed to have high user interactivity and low user-perceived latency . Real-time dynamic web data such as news headlines , stock tickers , and auction updates need to be propagated to the users as soon as possible . However , Ajax still suffers from the limitations of the Web's request/response architecture which prevents servers from pushing real-time dynamic web data . Such applications usually use a pull style to obtain the latest updates , where the client actively requests the changes based on a predefined interval . It is possible to overcome this limitation by adopting a push style of interaction where the server broadcasts data when a change occurs on the server side . Both these options have their own trade-offs . This paper explores the fundamental limits of browser-based applications and analyzes push solutions for Ajax technology . It also shows the results of an empirical study comparing push and pull .
0706.4004	cs.NI	End-to-End Available Bandwidth Measurement Tools : A Comparative Evaluation of Performances	In recent years , there has been a strong interest in measuring the available bandwidth of network paths . Several methods and techniques have been proposed and various measurement tools have been developed and evaluated . However , there have been few comparative studies with regards to the actual performance of these tools . This paper presents a study of available bandwidth measurement techniques and undertakes a comparative analysis in terms of accuracy , intrusiveness and response time of active probing tools . Finally , measurement errors and the uncertainty of the tools are analysed and overall conclusions made .
0706.4009	cs.DC	Multi-criteria scheduling of pipeline workflows	Mapping workflow applications onto parallel platforms is a challenging problem , even for simple application patterns such as pipeline graphs . Several antagonist criteria should be optimized , such as throughput and latency ( or a combination ) . In this paper , we study the complexity of the bi-criteria mapping problem for pipeline graphs on communication homogeneous platforms . In particular , we assess the complexity of the well-known chains-to-chains problem for different-speed processors , which turns out to be NP-hard . We provide several efficient polynomial bi-criteria heuristics , and their relative performance is evaluated through extensive simulations .
0706.4015	cs.DC	Self-Stabilizing Wavelets and r-Hops Coordination	We introduce a simple tool called the wavelet ( or , r-wavelet ) scheme . Wavelets deals with coordination among processes which are at most r hops away of each other . We present a selfstabilizing solution for this scheme . Our solution requires no underlying structure and works in arbritrary anonymous networks , i.e. , no process identifier is required . Moreover , our solution works under any ( even unfair ) daemon . Next , we use the wavelet scheme to design self-stabilizing layer clocks . We show that they provide an efficient device in the design of local coordination problems at distance r , i.e. , r-barrier synchronization and r-local resource allocation ( LRA ) such as r-local mutual exclusion ( LME ) , r-group mutual exclusion ( GME ) , and r-Reader/Writers . Some solutions to the r-LRA problem ( e.g. , r-LME ) also provide transformers to transform algorithms written assuming any r-central daemon into algorithms working with any distributed daemon .
0706.4035	cs.NI cs.CR	Encounter-based worms : Analysis and Defense	Encounter-based network is a frequently-disconnected wireless ad-hoc network requiring immediate neighbors to store and forward aggregated data for information disseminations . Using traditional approaches such as gateways or firewalls for deterring worm propagation in encounter-based networks is inappropriate . We propose the worm interaction approach that relies upon automated beneficial worm generation aiming to alleviate problems of worm propagations in such networks . To understand the dynamic of worm interactions and its performance , we mathematically model worm interactions based on major worm interaction factors including worm interaction types , network characteristics , and node characteristics using ordinary differential equations and analyze their effects on our proposed metrics . We validate our proposed model using extensive synthetic and trace-driven simulations . We find that , all worm interaction factors significantly affect the pattern of worm propagations . For example , immunization linearly decreases the infection of susceptible nodes while on-off behavior only impacts the duration of infection . Using realistic mobile network measurements , we find that encounters are bursty , multi-group and non-uniform . The trends from the trace-driven simulations are consistent with the model , in general . Immunization and timely deployment seem to be the most effective to counter the worm attacks in such scenarios while cooperation may help in a specific case . These findings provide insight that we hope would aid to develop counter-worm protocols in future encounter-based networks .
0706.4038	cs.DC	Scheduling multiple divisible loads on a linear processor network	Min , Veeravalli , and Barlas have recently proposed strategies to minimize the overall execution time of one or several divisible loads on a heterogeneous linear network , using one or more installments . We show on a very simple example that their approach does not always produce a solution and that , when it does , the solution is often suboptimal . We also show how to find an optimal schedule for any instance , once the number of installments per load is given . Then , we formally state that any optimal schedule has an infinite number of installments under a linear cost model as the one assumed in the original papers . Therefore , such a cost model can not be used to design practical multi-installment strategies . Finally , through extensive simulations we confirmed that the best solution is always produced by the linear programming approach , while solutions of the original papers can be far away from the optimal .
0706.4044	cs.LO cs.CC	PSPACE Bounds for Rank-1 Modal Logics	For lack of general algorithmic methods that apply to wide classes of logics , establishing a complexity bound for a given modal logic is often a laborious task . The present work is a step towards a general theory of the complexity of modal logics . Our main result is that all rank-1 logics enjoy a shallow model property and thus are , under mild assumptions on the format of their axiomatisation , in PSPACE . This leads to a unified derivation of tight PSPACE-bounds for a number of logics including K , KD , coalition logic , graded modal logic , majority logic , and probabilistic modal logic . Our generic algorithm moreover finds tableau proofs that witness pleasant proof-theoretic properties including a weak subformula property . This generality is made possible by a coalgebraic semantics , which conveniently abstracts from the details of a given model class and thus allows covering a broad range of logics in a uniform way .
0706.4048	cs.DC astro-ph	Getting More From Your Multicore : Exploiting OpenMP From An Open Source Numerical Scripting Language	We introduce SLIRP , a module generator for the S-Lang numerical scripting language , with a focus on its vectorization capabilities . We demonstrate how both SLIRP and S-Lang were easily adapted to exploit the inherent parallelism of high-level mathematical languages with OpenMP , allowing general users to employ tightly-coupled multiprocessors in scriptable research calculations while requiring no special knowledge of parallel programming . Motivated by examples in the ISIS astrophysical modeling & analysis tool , performance figures are presented for several machine and compiler configurations , demonstrating beneficial speedups for real-world operations .
0706.4107	cs.DS	Radix Sorting With No Extra Space	It is well known that n integers in the range [ 1 , n^c ] can be sorted in O ( n ) time in the RAM model using radix sorting . More generally , integers in any range [ 1 , U ] can be sorted in O ( n sqrt { loglog n } ) time . However , these algorithms use O ( n ) words of extra memory . Is this necessary ? We present a simple , stable , integer sorting algorithm for words of size O ( log n ) , which works in O ( n ) time and uses only O ( 1 ) words of extra memory on a RAM model . This is the integer sorting case most useful in practice . We extend this result with same bounds to the case when the keys are read-only , which is of theoretical interest . Another interesting question is the case of arbitrary c. Here we present a black-box transformation from any RAM sorting algorithm to a sorting algorithm which uses only O ( 1 ) extra space and has the same running time . This settles the complexity of in-place sorting in terms of the complexity of sorting .
