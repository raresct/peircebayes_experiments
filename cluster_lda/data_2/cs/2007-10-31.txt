0710.5830	cs.NI	Stability analysis of a max-min fair Rate Control Protocol ( RCP ) in a small buffer regime	In this note we analyse various stability properties of the max-min fair Rate Control Protocol ( RCP ) operating with small buffers . We first tackle the issue of stability for networks with arbitrary topologies . We prove that the max-min fair RCP fluid model is globally stable in the absence of propagation delays , and also derive a set of conditions for local stability when arbitrary heterogeneous propagation delays are present . The network delay stability result assumes that , at equilibrium , there is only one bottleneck link along each route . Lastly , in the simpler setting of a single link , single delay model , we investigate the impact of the loss of local stability via a Hopf bifurcation .
0710.5893	cs.IT math.IT	Codes from Zero-divisors and Units in Group Rings	We describe and present a new construction method for codes using encodings from group rings . They consist primarily of two types : zero-divisor and unit-derived codes . Previous codes from group rings focused on ideals ; for example cyclic codes are ideals in the group ring over a cyclic group . The fresh focus is on the encodings themselves , which only under very limited conditions result in ideals . We use the result that a group ring is isomorphic to a certain well-defined ring of matrices , and thus every group ring element has an associated matrix . This allows matrix algebra to be used as needed in the study and production of codes , enabling the creation of standard generator and check matrices . Group rings are a fruitful source of units and zero-divisors from which new codes result . Many code properties , such as being LDPC or self-dual , may be expressed as properties within the group ring thus enabling the construction of codes with these properties . The methods are general enabling the construction of codes with many types of group rings . There is no restriction on the ring and thus codes over the integers , over matrix rings or even over group rings themselves are possible and fruitful .
0710.5895	cs.PL cs.LO cs.SE	Source-to-source optimizing transformations of Prolog programs based on abstract interpretation	Making a Prolog program more efficient by transforming its source code , without changing its operational semantics , is not an obvious task . It requires the user to have a clear understanding of how the Prolog compiler works , and in particular , of the effects of impure features like the cut . The way a Prolog code is written - e.g. , the order of clauses , the order of literals in a clause , the use of cuts or negations - influences its efficiency . Furthermore , different optimization techniques may be redundant or conflicting when they are applied together , depending on the way a procedure is called - e.g. , inserting cuts and enabling indexing . We present an optimiser , based on abstract interpretation , that automatically performs safe code transformations of Prolog procedures in the context of some class of input calls . The method is more effective if procedures are annotated with additional information about modes , types , sharing , number of solutions and the like . Thus the approach is similar to Mercury . It applies to any Prolog program , however .
0711.0048	cs.PL cs.SE	Declarative Diagnosis of Floundering	Many logic programming languages have delay primitives which allow coroutining . This introduces a class of bug symptoms -- computations can flounder when they are intended to succeed or finitely fail . For concurrent logic programs this is normally called deadlock . Similarly , constraint logic programs can fail to invoke certain constraint solvers because variables are insufficiently instantiated or constrained . Diagnosing such faults has received relatively little attention to date . Since delay primitives affect the procedural but not the declarative view of programs , it may be expected that debugging would have to consider the often complex details of interleaved execution . However , recent work on semantics has suggested an alternative approach . In this paper we show how the declarative debugging paradigm can be used to diagnose unexpected floundering , insulating the user from the complexities of the execution . Keywords : logic programming , coroutining , delay , debugging , floundering , deadlock , constraints
