0707.4083	cs.IT math.IT	Chain of Separable Binary Goppa Codes and their Minimal Distance	It is shown that subclasses of separable binary Goppa codes , $ \Gamma ( L , G ) $ - codes , with $ L=\ { \alpha \in GF ( 2^ { 2l } ) : G ( \alpha ) \neq 0 \ } $ and special Goppa polynomials G ( x ) can be presented as a chain of embedded codes . The true minimal distance has been obtained for all codes of the chain .
0707.4104	cs.DM math.CO	Queues , stores , and tableaux	Consider the single server queue with an infinite buffer and a FIFO discipline , either of type M/M/1 or Geom/Geom/1 . Denote by A the arrival process and by s the services . Assume the stability condition to be satisfied . Denote by D the departure process in equilibrium and by r the time spent by the customers at the very back of the queue . We prove that ( D , r ) has the same law as ( A , s ) which is an extension of the classical Burke Theorem . In fact , r can be viewed as the departures from a dual storage model . This duality between the two models also appears when studying the transient behavior of a tandem by means of the RSK algorithm : the first and last row of the resulting semi-standard Young tableau are respectively the last instant of departure in the queue and the total number of departures in the store .
0707.4124	cs.DM	Services within a busy period of an M/M/1 queue and Dyck paths	We analyze the service times of customers in a stable M/M/1 queue in equilibrium depending on their position in a busy period . We give the law of the service of a customer at the beginning , at the end , or in the middle of the busy period . It enables as a by-product to prove that the process of instants of beginning of services is not Poisson . We then proceed to a more precise analysis . We consider a family of polynomial generating series associated with Dyck paths of length 2n and we show that they provide the correlation function of the successive services in a busy period with ( n+1 ) customers .
0707.4133	cs.IT math.IT	Multiuser Successive Refinement and Multiple Description Coding	We consider the multiuser successive refinement ( MSR ) problem , where the users are connected to a central server via links with different noiseless capacities , and each user wishes to reconstruct in a successive-refinement fashion . An achievable region is given for the two-user two-layer case and it provides the complete rate-distortion region for the Gaussian source under the MSE distortion measure . The key observation is that this problem includes the multiple description ( MD ) problem ( with two descriptions ) as a subsystem , and the techniques useful in the MD problem can be extended to this case . We show that the coding scheme based on the universality of random binning is sub-optimal , because multiple Gaussian side informations only at the decoders do incur performance loss , in contrast to the case of single side information at the decoder . We further show that unlike the single user case , when there are multiple users , the loss of performance by a multistage coding approach can be unbounded for the Gaussian source . The result suggests that in such a setting , the benefit of using successive refinement is not likely to justify the accompanying performance loss . The MSR problem is also related to the source coding problem where each decoder has its individual side information , while the encoder has the complete set of the side informations . The MSR problem further includes several variations of the MD problem , for which the specialization of the general result is investigated and the implication is discussed .
0707.4166	cs.SE	Parsimony Principles for Software Components and Metalanguages	Software is a communication system . The usual topic of communication is program behavior , as encoded by programs . Domain-specific libraries are codebooks , domain-specific languages are coding schemes , and so forth . To turn metaphor into method , we adapt toolsfrom information theory -- the study of efficient communication -- to probe the efficiency with which languages and libraries let us communicate programs . In previous work we developed an information-theoretic analysis of software reuse in problem domains . This new paper uses information theory to analyze tradeoffs in the design of components , generators , and metalanguages . We seek answers to two questions : ( 1 ) How can we judge whether a component is over- or under-generalized ? Drawing on minimum description length principles , we propose that the best component yields the most succinct representation of the use cases . ( 2 ) If we view a programming language as an assemblage of metalanguages , each providing a complementary style of abstraction , how can these metalanguages aid or hinder us in efficiently describing software ? We describe a complex triangle of interactions between the power of an abstraction mechanism , the amount of reuse it enables , and the cognitive difficulty of its use .
0707.4198	cs.OH	Reductionism , emergence , and levels of abstractions	Can there be independent higher level laws of nature if everything is reducible to the fundamental laws of physics ? The computer science notion of level of abstraction explains why there can -- illustrating how computational thinking can solve one of philosophy 's most vexing problems .
